// Decompiled with JetBrains decompiler
// Type: Microsoft.TeamFoundation.WorkItemTracking.Server.Query.QueryProcessor.QueryTexts
// Assembly: Microsoft.TeamFoundation.WorkItemTracking.Server, Version=19.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: B0AE48DA-B6D2-466C-91D8-D0BF0F05DE87
// Assembly location: C:\Program Files\Azure DevOps Server 2022\Application Tier\Web Services\bin\Plugins\Microsoft.TeamFoundation.WorkItemTracking.Server.dll

namespace Microsoft.TeamFoundation.WorkItemTracking.Server.Query.QueryProcessor
{
  internal static class QueryTexts
  {
    public const string c_inGroupTempTable = "\r\nCREATE TABLE #temp{0}\r\n(\r\n    X NVARCHAR(256) COLLATE DATABASE_DEFAULT NOT NULL,\r\n    UNIQUE CLUSTERED (X) WITH (IGNORE_DUP_KEY=ON)\r\n)\r\n\r\nINSERT #temp{0}\r\nSELECT String\r\nFROM dbo.func_ExplodeSetAll({1}, {2})\r\n\r\n";
    public const string c_inGroupConstIdTempTable = "\r\nCREATE TABLE #temp{0}\r\n(\r\n    X INT NOT NULL,\r\n    UNIQUE CLUSTERED (X) WITH (IGNORE_DUP_KEY=ON)\r\n)\r\n\r\nINSERT #temp{0}\r\nSELECT ConstId\r\nFROM dbo.func_ExplodeSetAllConstId({1}, {2})\r\n\r\n";
    public const string c_AADInGroupIdentityTempTable = "\r\nCREATE TABLE #temp{0}\r\n(\r\n    X NVARCHAR(256) COLLATE DATABASE_DEFAULT NOT NULL,\r\n    UNIQUE CLUSTERED (X) WITH (IGNORE_DUP_KEY=ON)\r\n)\r\n\r\n;WITH AllNames\r\nas\r\n(\r\nSELECT IdentityDisplayName, DisplayPart FROM Constants C\r\nJOIN {1} T\r\nON T.Id = C.TeamFoundationId\r\nWHERE C.PartitionId = {2}\r\n)\r\n-- insert all display parts and their ambiguous versions.\r\nINSERT #temp{0}\r\nSELECT DisplayPart FROM AllNames\r\nUNION\r\nSELECT C.DisplayPart FROM Constants C\r\nJOIN AllNames A\r\nON A.IdentityDisplayName = C.DisplayPart\r\nWHERE C.PartitionId = {2}\r\nAND C.TeamFoundationId IS NULL\r\n;\r\n";
    public const string c_AADInGroupIdentityConstIdTempTable = "\r\nCREATE TABLE #temp{0}\r\n(\r\n    X INT NOT NULL,\r\n    UNIQUE CLUSTERED (X) WITH (IGNORE_DUP_KEY=ON)\r\n)\r\n\r\n;WITH AllNames\r\nas\r\n(\r\nSELECT C.ConstId, IdentityDisplayName FROM Constants C\r\nJOIN {1} T\r\nON T.Id = C.TeamFoundationId\r\nWHERE C.PartitionId = {2}\r\n)\r\n-- insert all constId and their ambiguous versions's constId.\r\nINSERT #temp{0}\r\nSELECT ConstId FROM AllNames\r\nUNION\r\nSELECT C.ConstId FROM Constants C\r\nJOIN AllNames A\r\nON A.IdentityDisplayName = C.DisplayPart\r\nWHERE C.PartitionId = {2}\r\nAND C.TeamFoundationId IS NULL\r\n;\r\n";
    public const string c_treeQueryParentFirstTempTable = "\r\nDECLARE @Count INT\r\n\r\nCREATE TABLE #roots\r\n(\r\n    Id INT NOT NULL,\r\n    Path VARBINARY(880) NOT NULL UNIQUE CLUSTERED,\r\n    Level INT NULL\r\n)\r\n\r\nCREATE TABLE #results\r\n(\r\n    SourceId    INT NOT NULL,\r\n    TargetId    INT NOT NULL UNIQUE CLUSTERED,\r\n    IsLocked    BIT NOT NULL,\r\n    MeetsParentCriteria BIT NOT NULL,\r\n    Level       INT NULL\r\n)\r\n\r\nCREATE TABLE #results_filtered\r\n(\r\n    SourceId            INT NOT NULL,\r\n    TargetId            INT NOT NULL,\r\n    IsLocked            BIT NOT NULL,\r\n    MeetsParentCriteria BIT NOT NULL,\r\n    MeetsChildCriteria  BIT NOT NULL,\r\n    TargetLatestAreaId  INT NOT NULL,\r\n    Level               INT NULL,\r\n    IsRemoveable        BIT NOT NULL,\r\n    RowNumber           INT NULL,\r\n    UNIQUE CLUSTERED (Level, TargetId, SourceId, MeetsParentCriteria, MeetsChildCriteria, IsRemoveable) WITH (IGNORE_DUP_KEY=ON)\r\n)\r\n\r\nCREATE TABLE #nodes_meet_parent\r\n(\r\n    Id INT NOT NULL UNIQUE CLUSTERED\r\n)\r\n\r\nINSERT #roots (Id, Path, Level)\r\n";
    public const string c_treeQuerryPreProcessForExceedingLimitImprovement = " \r\nDECLARE @maxLevel INT\r\n\r\nSELECT TOP 1 @maxLevel = Level -- Get the deepest children level \r\nFROM #results_filtered\r\nORDER BY Level DESC\r\n\r\nWHILE @maxLevel > 4 -- Do not process on root level (Level = 4), they are always preserved\r\nBEGIN\r\n    UPDATE     L\r\n    SET        IsRemoveable = 1\r\n    FROM       #results_filtered L\r\n    LEFT JOIN  #results_filtered R \r\n    ON         L.TargetId = R.SourceId\r\n               AND R.Level = @maxLevel + 4 \r\n               AND R.IsRemoveable = 0 -- Non-removeable children \r\n    WHERE      L.Level = @maxLevel  \r\n               AND L.MeetsChildCriteria = 0 -- this node can't be a child\r\n               AND L.MeetsParentCriteria = 0 -- this node can't be a parent\r\n               AND R.Level IS NULL -- this node does not have non-removeable children\r\n\r\n    SET @maxLevel = @maxLevel - 4\r\nEND\r\n";
    public const string c_treeQueryInsertIntoFilteredResults = "\r\nINSERT #results_filtered (SourceId, TargetId, IsLocked, MeetsParentCriteria, MeetsChildCriteria, TargetLatestAreaId, Level, IsRemoveable)\r\n{0}\r\n";
    public const string c_treeQueryInsertIntoFilteredResultsWithRowNumber = "\r\nINSERT #results_filtered (SourceId, TargetId, IsLocked, MeetsParentCriteria, MeetsChildCriteria, TargetLatestAreaId, Level, IsRemoveable, RowNumber)\r\n{0}\r\n";
    public const string c_treeQueryParentFirstRecurse = "\r\nSELECT @Count = @@rowcount\r\n\r\nDELETE Roots\r\nOUTPUT 0, deleted.Id, 0, 1, deleted.Level\r\nINTO #results\r\nFROM #roots Roots\r\nWHERE Roots.Path > 0x7FFFFFFF\r\n\r\nSELECT @Count = @Count - @@rowcount\r\n\r\nIF (@Count < 5000)\r\nBEGIN\r\n    DELETE Children\r\n    OUTPUT deleted.Id\r\n    INTO #nodes_meet_parent\r\n    FROM #roots as Parents\r\n    JOIN #roots as Children WITH(forceseek)\r\n        ON Children.Path > Parents.Path\r\n        AND Children.Path < Parents.Path + 0x7FFFFFFF\r\nEND\r\nELSE\r\nBEGIN\r\n    CREATE NONCLUSTERED INDEX RootLevels ON #roots\r\n    (\r\n        Level ASC,\r\n        Path ASC\r\n    )\r\n\r\n    DECLARE @minLevel SMALLINT\r\n    DECLARE @curLevel SMALLINT\r\n\r\n    SELECT TOP 1 @minLevel = Level\r\n    FROM #roots\r\n    ORDER BY Level ASC\r\n\r\n    WHILE @minLevel <> 0\r\n    BEGIN\r\n        DELETE Children\r\n        OUTPUT deleted.Id\r\n        INTO #nodes_meet_parent\r\n        FROM #roots as Parents\r\n        JOIN #roots as Children WITH(forceseek)\r\n            ON Children.Path > Parents.Path\r\n            AND Children.Path < Parents.Path + 0x7FFFFFFF\r\n            AND Parents.Level = @minLevel\r\n\r\n        SET @curLevel = @minLevel\r\n        SET @minLevel = 0 \r\n\r\n        SELECT TOP 1 @minLevel = Level\r\n        FROM #roots\r\n        WHERE Level > @curLevel\r\n        ORDER BY Level ASC\r\n    END\r\nEND\r\n\r\nINSERT #results (SourceId, TargetId, IsLocked, MeetsParentCriteria, Level)\r\nSELECT CASE\r\n        WHEN Children.TargetId IS NULL THEN 0\r\n        WHEN Children.TargetId = Parents.Id THEN 0\r\n        ELSE Children.SourceId\r\n    END AS SourceId,\r\n    ISNULL(Children.TargetId, Parents.Id) AS TargetId,\r\n    CONVERT(BIT,\r\n        CASE\r\n            WHEN Children.SourceId IS NULL THEN 0\r\n            ELSE ISNULL(Children.fLock, 0)\r\n        END) AS IsLocked,\r\n    CONVERT(BIT,\r\n        CASE\r\n            WHEN Children.TargetId IS NULL THEN 1\r\n            WHEN Children.TargetId = Parents.Id THEN 1\r\n            WHEN Children.TargetId = n.ID then 1\r\n            ELSE 0\r\n        END) AS MeetsParentCriteria, \r\n    DATALENGTH(Children.Path)\r\nFROM #roots AS Parents\r\nLEFT JOIN dbo.LinkTreesLatest AS Children\r\n    ON Children.Path >= Parents.Path\r\n    AND Children.Path < Parents.Path + 0x7FFFFFFF\r\n    AND Children.LinkType = {0}\r\n    AND Children.PartitionId = {1}\r\nLEFT JOIN #nodes_meet_parent n\r\n    ON Children.TargetId = n.Id\r\n";
    public const string c_treeQueryChildFirstTempTable = "\r\nCREATE TABLE #results (\r\n    SourceId INT NOT NULL,\r\n    TargetId INT NOT NULL,\r\n    IsLocked BIT NOT NULL,\r\n    Level INT NOT NULL,\r\n    MeetsChildCriteria BIT NOT NULL,\r\n\r\n    UNIQUE CLUSTERED (Level, TargetId) WITH (IGNORE_DUP_KEY=ON)\r\n)\r\n\r\nINSERT #results(SourceId, TargetId, IsLocked, Level, MeetsChildCriteria)\r\n";
    public const string c_treeQueryChildFirstRecurse = "\r\n\r\nDECLARE @maxLevel SMALLINT\r\n\r\nSELECT TOP 1 @maxLevel = Level\r\nFROM #results\r\nORDER BY Level DESC\r\n\r\nWHILE @maxLevel > 4\r\nBEGIN\r\n    INSERT #results(SourceId, TargetId, IsLocked, Level, MeetsChildCriteria)\r\n    SELECT S.SourceId, S.TargetId, S.IsLocked, S.Level, 0\r\n    FROM\r\n    (\r\n        SELECT DISTINCT ISNULL(p.SourceID, 0) as SourceId,\r\n            p.TargetID as TargetId,\r\n            ISNULL(p.fLock, CAST(0 AS BIT)) AS IsLocked,\r\n            DATALENGTH(p.Path) as Level\r\n        FROM #results c\r\n        JOIN dbo.LinkTreesLatest p\r\n            ON c.Level = @maxLevel\r\n            AND c.SourceId = p.TargetID\r\n            AND p.LinkType = {0}\r\n                            AND p.PartitionId = {1}\r\n    ) S\r\n    LEFT JOIN #results T\r\n        ON T.TargetId = S.TargetId\r\n        AND T.Level = S.Level\r\n    WHERE T.TargetId IS NULL\r\n                    OPTION (LOOP JOIN)\r\n    \r\n    SET @maxLevel = @maxLevel - 4\r\nEND\r\n\r\n";
    public const string c_treeQueryShouldOptimizeForExceedingLimitImprovement = "\r\nSELECT @Count = COUNT(*) FROM #results\r\nIF (@Count >= {0})\r\nBEGIN\r\n{1}\r\nEND\r\nELSE\r\nBEGIN\r\n{2}\r\nEND\r\n";
  }
}
